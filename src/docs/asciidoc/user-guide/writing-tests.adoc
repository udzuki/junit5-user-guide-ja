include::../link-attributes.adoc[]

[[writing-tests]]
== テストを書く

[source,java,indent=0]
.A first test case
----
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

class FirstJUnit5Tests {

    @Test
    void myFirstTest() {
        assertEquals(2, 1 + 1);
    }

}
----

[[writing-tests-annotations]]
=== アノテーション

JUnit Jupiterは、テストの設定やフレームワークの拡張のために、
次のアノテーションをサポートしています。

全てのコアなアノテーションは、 `junit-jupiter-api` モジュール内の
`{api-package}` パッケージにあります。

|===
|アノテーション | 説明

| `@Test` | テストメソッドであることを意味します。JUnit 4の `@Test` と異なり、このアノテーションはいかなる属性も宣言しません。これは、JUnit Jupiterにおけるテスト拡張が専用のアノテーションを元に作動するからです。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@ParameterizedTest` | <<writing-tests-parameterized-tests, パラメータ化テスト>> であることを意味します。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@RepeatedTest` | <<writing-tests-repeated-tests, 繰り返しテスト>> のテンプレートメソッドであることを意味します。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@TestFactory` | <<writing-tests-dynamic-tests, 動的テスト>> のファクトリーメソッドであることを意味します。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@TestInstance` | アノテーションが付与されたテストクラスの <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> を設定するために使用されます。アノテーションは _継承_ されます。
| `@TestTemplate` | <<writing-tests-test-templates, テストケースのテンプレート>> メソッドであることを意味します。テンプレートは登録された <<extensions-test-templates, プロバイダ>> によって返される呼び出しコンテキストの数に応じて複数回呼び出されます。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@DisplayName` | テストクラスもしくはテストメソッドのカスタム表示名を宣言します。アノテーションは _継承_ されません。
| `@BeforeEach` | 現在のクラス内にある *各テスト* （ `@Test` , `@RepeatedTest` , `@ParameterizedTest` , `@TestFactory` ）が実行される _前_ （ _before_ ）に実行されるメソッドを意味します。JUnit 4の `@Before` と類似したものです。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@AfterEach` | 現在のクラス内にある *各テスト* （ `@Test` , `@RepeatedTest` , `@ParameterizedTest` , `@TestFactory` ）が実行された _後_ （ _after_ ）に実行されるメソッドを意味します。JUnit 4の `@After` と類似したものです。メソッドは _オーバーライド_ されない限り、 _継承_ されます。
| `@BeforeAll` | 現在のクラス内にある *全テスト* （ `@Test` , `@RepeatedTest` , `@ParameterizedTest` , `@TestFactory` ）が実行される _前_ （ _before_ ）に実行されるメソッドを意味します。JUnit 4の `@BeforeClass` と類似したものです。メソッドは _隠蔽_ または _オーバーライド_ されない限り、 _継承_ され、（"クラス毎の" <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> を使わない限り） `static` でないといけません。
| `@AfterAll` | 現在のクラス内にある *全テスト* （ `@Test` , `@RepeatedTest` , `@ParameterizedTest` , `@TestFactory` ）が実行された _後_ （ _after_ ）に実行されるメソッドを意味します。JUnit 4の `@AfterClass` と類似したものです。メソッドは _隠蔽_ または _オーバーライド_ されない限り、 _継承_ され、（"クラス毎の" <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> を使わない限り） `static` でないといけません。
| `@Nested` | ネストされた非staticなテストクラスであることを意味します。 `@BeforeAll` と `@AfterAll` メソッドは、"クラス毎の" <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> を使わない限り、 `@Nested` テストクラスの中では直接使うことができません。メソッドは _継承_ されません。
| `@Tag` |クラスもしくはメソッドレベルでテストをフィルタリングするための _タグ_ を宣言できます。TestNGのtest groupsもしくはJUnit 4のCategoriesと類似したものです。アノテーションはクラスレベルでは _継承_ されますが、メソッドレベルでは _継承_ されません。
| `@Disabled` | テストクラスもしくはテストメソッドを _無効化_ できます。JUnit 4の `@Ignore` と類似したものです。アノテーションは _継承_ されません。
| `@ExtendWith` | カスタム <<extensions,拡張>> を登録できます。アノテーションは _継承_ されます。
|===

次のアノテーションをつけたメソッドは値を返してはいけません。
( `@Test` , `@TestTemplate` , `@RepeatedTest` , `@BeforeAll` , `@AfterAll` , `@BeforeEach` , `@AfterEach` )


[NOTE]
====
いくつかのアノテーションは現在 _実験段階_ である恐れがあります。
詳細に関しては、 <<api-evolution-experimental-apis, 実験的なAPIs>> をご覧ください。
====

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

JUnit Jupiterアノテーションはメタアノテーションとして使うことができます。
つまり、メタアノテーションのセマンティックを自動で _継承_ する
独自の _合成アノテーション_ を定義できます。

例えば、コードベースに `@Tag("fast")` （<<writing-tests-tagging-and-filtering,タグ付けとフィルタリング>> をご覧ください。）を
コピー＆ペーストする代わりに、次のように `@Fast` というカスタム _合成アノテーション_ を作成できます。
`@Fast` は `@Tag("fast")` の代替として利用できます。

[source,java]
----
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.junit.jupiter.api.Tag;

@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Tag("fast")
public @interface Fast {
}
----

[[writing-tests-classes-and-methods]]
=== テストクラスとメソッド

_テストメソッド_ とは、直接もしくはメタ的に `@Test` または `@RepeatedTest` 、 `@ParamterizedTest` 、 `@TsetFactory`、 `@TestTemplate` が
付与されたインスタンスメソッドです。 _テストクラス_ とは、少なくとも1つのテストメソッドを含むトップレベルまたは静的なメンバークラスです。



[source,java]
.標準的なテストケース
----
import static org.junit.jupiter.api.Assertions.fail;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {

    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }

}
----

[NOTE]
====
テストクラスもテストメソッドも `public` である必要はありません。
====


[[writing-tests-display-names]]
=== 表示名

テストクラスとテストメソッドはカスタム表示名（スペースや特殊文字、絵文字も使用可能です） を宣言できます。
それらがテストランナーとテストレポートによって表示されます。

[source,java]
----
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
----

[[writing-tests-assertions]]
=== アサーション

JUnit Jupiterには、JUnit 4のアサーションメソッドの多くを備えています。
また、いくつかはJava 8のラムダ式で使うことができます。
全てのJUnit Jupiterアサーションは、 `{Assertions}` クラスの `static` メソッドです。

[source,java]
----
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.Test;

class AssertionsDemo {

    @Test
    void standardAssertions() {
        assertEquals(2, 2);
        assertEquals(4, 4, "The optional assertion message is now the last parameter.");
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
                + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and any
        // failures will be reported together.
        assertAll("person",
            () -> assertEquals("John", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("n"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
        Throwable exception = assertThrows(IllegalArgumentException.class, () -> {
            throw new IllegalArgumentException("a message");
        });
        assertEquals("a message", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
            // Perform task that takes less than 2 minutes.
        });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
----

また、JUnit Jupiterのいくつかのアサーションメソッドは
https://kotlinlang.org/[Kotlin] で使うことができます。
全てのJUnit Jupiter Kotlinアサーションは、 `org.junit.jupiter.api` パッケージのトップレベル関数です。

[source,kotlin]
----
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.assertThrows

class AssertionsKotlinDemo {

    @Test
    fun `grouped assertions`() {
        assertAll("person",
            { assertEquals("John", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `exception testing`() {
        val exception = assertThrows<IllegalArgumentException> ("Should throw an exception") {
            throw IllegalArgumentException("a message")
        }
        assertEquals("a message", exception.message)
    }

    @Test
    fun `assertions from a stream`() {
        assertAll(
            "people with name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `assertions from a collection`() {
        assertAll(
            "people with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

}
----

[[writing-tests-assertions-third-party]]
==== サードパーティのアサーションライブラリ

JUnit Jupiterによって提供されているアサーション機能は多くのテストシナリオで十分ですが、
_matchers_ といったより強力で追加的な機能が求められたり必要な場合があります。
そのような場合、JUnitチームは、 {AssertJ} や {Hamcrest} 、 {Truth} などといった
サードパーティのアサーションライブラリの使用をお薦めします。
したがって、開発者は自由に選んだアサーションライブラリを使うことができます。

例えば、 _matchers_ と流暢なAPI（fluent API）の組み合わせは、
アサーションをよりわかりやすく、読みやすくするために使うことができます。
しかしながら、JUnit Jupiterの `{Assertions}` クラスは、Hamcrestの http://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]を
許容しているJUnit 4の `org.junit.Assert` クラスにあるような http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`] メソッドを提供していません。
代わりに、開発者はサードパーティのアサーションライブラリによって提供されているマッチャー用の組み込みサポートを使うことが奨励されています。

次の例は、JUnit JupiterのテストにおいてHamcrestから `assertThat()` のサポートを使う方法を説明しています。
Hamcrestライブラリがクラスパスに加えられている限り、 `assertThat()` や `is()` 、 `equalTo()` といった
メソッドを静的にインポートできます。また、それらをテストの中で、下に示す `assertWithHamcrestMatcher()` のように使うことができます。

[source,java]
----
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import org.junit.jupiter.api.Test;

class HamcrestAssertionDemo {

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(2 + 1, is(equalTo(3)));
    }

}
----

当然、JUnit 4のプログラミングモデルに基づいたレガシーテストも
`org.junit.Assert#assertThat` を用いて継続して利用可能です。

[[writing-tests-assumptions]]
=== アサンプション

JUnit Jupiterは、JUnit 4のアサンプションメソッドのサブセットを備えています。
また、いくつかはJava 8のラムダ式で使うことができます。
全てのJUnit Jupiterアサンプションは、 `{Assumptions}` クラスの `static` メソッドです。

[source,java]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
        // remainder of test
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
        assumeTrue("DEV".equals(System.getenv("ENV")),
            () -> "Aborting test: not on developer workstation");
        // remainder of test
    }

    @Test
    void testInAllEnvironments() {
        assumingThat("CI".equals(System.getenv("ENV")),
            () -> {
                // perform these assertions only on the CI server
                assertEquals(2, 2);
            });

        // perform these assertions in all environments
        assertEquals("a string", "a string");
    }

}
----

[[writing-tests-disabling]]
=== テストの無効化

テストクラス全体もしくは各テストメソッドは、 `{Disabled}` アノテーション
または <<writing-tests-conditional-execution, 条件付きテスト実行>> で議論されているアノテーションの1つ、
カスタム <<extensions-conditions, `ExecutionCondition`>> によって _無効化_ できます。

これは `@Disabled` テストクラスです。

[source,java]
----
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

@Disabled
class DisabledClassDemo {
    @Test
    void testWillBeSkipped() {
    }
}
----

そして、これは `@Disabled` テストメソッドを含むテストクラスです。

[source,java]
----
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class DisabledTestsDemo {

    @Disabled
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }
}
----

[[writing-tests-conditional-execution]]
=== 条件付きテスト実行

JUnit Jupiterの <<extensions-conditions, `ExecutionCondition`>> 拡張APIを用いて、
ある条件に基づいたコンテナまたはテストを _プログラム的に_ _有効_ または _無効_ にできます。
そのような条件の最も単純な例は、`{Disabled}` アノテーションをサポートしている
組み込みの `{DisabledCondition}` です（ <<writing-tests-disabling, テストの無効化>> をご覧ください）。
`@Disabled` に加えて、JUnit Jupiterは、 `org.junit.jupiter.api.condition` パッケージに
他のいくつかのアノテーションベースの条件もサポートしており、コンテナやテストを _宣言的に_
_有効_ または _無効_ にできます。詳細については、次章をご覧ください。

[TIP]
.合成アノテーション
====
次章に列挙する _条件_ アノテーションはいずれも、カスタム _合成アノテーション_ を作るために
メタアノテーションとしても使える可能性があります。
例えば、 <<writing-tests-conditional-execution-os-demo, @EnabledOnOsのデモ>> にある
`@TestOnMac` アノテーションは、 `@Test` と `@EnableOnOs` を単一で再利用可能な
アノテーションに組み合わせる方法を示しています。
====


[WARNING]
====
次章に列挙する _条件_ アノテーションはそれぞれ、
テストインターフェイスまたはテストクラス、テストメソッドに一度だけ宣言できます。
もし条件アノテーションがある要素に直接的か間接的、またはメタ的に複数存在する場合、
JUnitによって発見された最初のアノテーションのみ使われます
（いかなる追加的なアノテーションも静かに無視されます）。
しかしながら、 `org.junit.jupiter.api.condition` パッケージでは、
各条件アノテーションは他の条件アノテーションと共に使われる可能性があります。
====

[[writing-tests-conditional-execution-os]]
==== オペレーティングシステムに関する条件

`{EnabledOnOs}` と `{DisabledOnOs}` アノテーションを使うことで、
特定のオペーティングシステム上でコンテナまたはテストを有効にしたり無効にできます。

[[writing-tests-conditional-execution-os-demo]]
[source,java]
----
@Test
@EnabledOnOs(MAC)
void onlyOnMacOs() {
    // ...
}

@TestOnMac
void testOnMac() {
    // ...
}

@Test
@EnabledOnOs({ LINUX, MAC })
void onLinuxOrMac() {
    // ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    // ...
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Test
@EnabledOnOs(MAC)
@interface TestOnMac {
}
----

[[writing-tests-conditional-execution-jre]]
==== Java実行環境に関する条件

`{EnabledOnJre}` と `{DisabledOnJre}` アノテーションを使うことで、
特定のバージョンのJava実行環境（JRE）上でコンテナまたはテストを有効にしたり無効にできます。

[source,java]
----
@Test
@EnabledOnJre(JAVA_8)
void onlyOnJava8() {
    // ...
}

@Test
@EnabledOnJre({ JAVA_9, JAVA_10 })
void onJava9Or10() {
    // ...
}

@Test
@DisabledOnJre(JAVA_9)
void notOnJava9() {
    // ...
}
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティに関する条件

`{EnabledIfSystemProperty}` と `{DisabledIfSystemProperty}` アノテーションを使うことで、
`named` で指定したJVMシステムプロパティの値に応じて、
コンテナまたはテストを有効にしたり無効にできます。
`matches` 属性を使うことで、値は正規表現として解釈されます。

[source,java]
----
@Test
@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
void onlyOn64BitArchitectures() {
    // ...
}

@Test
@DisabledIfSystemProperty(named = "ci-server", matches = "true")
void notOnCiServer() {
    // ...
}
----

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数に関する条件

`{EnabledIfEnvironmentVariable}` と `{DisabledIfEnvironmentVariable}` アノテーションを使うことで、
基礎となるオペレーティングシステムからの `named` で指定した環境変数の値に応じて、
コンテナまたはテストを有効にしたり無効にできます。
`matches` 属性を使うことで、値は正規表現として解釈されます。

[source,java]
----
@Test
@EnabledIfEnvironmentVariable(named = "ENV", matches = "staging-server")
void onlyOnStagingServer() {
    // ...
}

@Test
@DisabledIfEnvironmentVariable(named = "ENV", matches = ".*development.*")
void notOnDeveloperWorkstation() {
    // ...
}
----

[[writing-tests-conditional-execution-scripts]]
==== スクリプトベースの条件

JUnit Jupiterは、 `{EnabledIf}` と `{DisabledIf}` アノテーションを使うことで、
設定されたスクリプトの評価値に応じて、コンテナまたはテストを有効にしたり無効にできる機能を提供しています。
スクリプトは、JavaScriptまたはGroovy、
JSR 223で定義されているJava Scripting APIをサポートしているスクリプト言語であれば記述できます。

WARNING: `{EnabledIf}` と `{DisabledIf}` を使った条件付きテストテスト実行は、
現在 _実験的な_ 機能です。
詳細については、 <<api-evolution-experimental-apis, _実験的な_ APIs>> をご覧ください。

TIP:  スクリプトのロジックが、現オペレーティングまたは現Java実行環境のバージョン、
特定のJVMシステムプロパティ、特定の環境変数にのみ依存している場合、
その目的に合った組み込みのアノテーションを使うことを考慮すべきです。
さらなる詳細については、前章をご覧ください。

NOTE: 同じスクリプトベースの条件を多数使っている場合、より速く、型安全で、
メンテナンスのしやすい方法で条件を実装するために、それに合った
<<extensions-conditions, ExecutionCondition>> 拡張を書くことを考えてみてください。


[source,java]
----
@Test // Static JavaScript expression.
@EnabledIf("2 * 3 == 6")
void willBeExecuted() {
    // ...
}

@RepeatedTest(10) // Dynamic JavaScript expression.
@DisabledIf("Math.random() < 0.314159")
void mightNotBeExecuted() {
    // ...
}

@Test // Regular expression testing bound system property.
@DisabledIf("/32/.test(systemProperty.get('os.arch'))")
void disabledOn32BitArchitectures() {
    assertFalse(System.getProperty("os.arch").contains("32"));
}

@Test
@EnabledIf("'CI' == systemEnvironment.get('ENV')")
void onlyOnCiServer() {
    assertTrue("CI".equals(System.getenv("ENV")));
}

@Test // Multi-line script, custom engine name and custom reason.
@EnabledIf(value = {
                "load('nashorn:mozilla_compat.js')",
                "importPackage(java.time)",
                "",
                "var today = LocalDate.now()",
                "var tomorrow = today.plusDays(1)",
                "tomorrow.isAfter(today)"
            },
            engine = "nashorn",
            reason = "Self-fulfilling: {result}")
void theDayAfterTomorrow() {
    LocalDate today = LocalDate.now();
    LocalDate tomorrow = today.plusDays(1);
    assertTrue(tomorrow.isAfter(today));
}
----

[[writing-tests-conditional-execution-scripts-bindings]]
===== スクリプトバインディング

次の名前は、各スクリプトコンテキストでバインドされているため、スクリプト内で使用可能です。*accessor*は、単純な `String get(String name)`メソッドを介してマップライク（map-like）な構造へのアクセスを提供します。

|===
|Name |Type |Description

|`systemEnvironment` | _accessor_ |オペレーティングシステム環境変数のアクセサ
|`systemProperty` | _accessor_ |JVMシステムプロパティのアクセサ
|`junitConfigurationParameter` | _accessor_ |設定パラメータのアクセサ
|`junitDisplayName` | `String` |テストまたはコンテナの表示名
|`junitTags` |`Set<String>` |テストまたはコンテナに振られている全てのタグ
|`junitUniqueId` |`String` |テストまたはコンテナのユニークなID
|===

[[writing-tests-tagging-and-filtering]]
=== タグとフィルタリング
テストクラスとメソッドは `@Tag` アノテーションを用いてタグ付けできます。
それらのタグは後に <<running-tests,テスト発見と実行>> をフィルタリングするために使われます。

==== タグの構文規則

* タグは `null` か _空_ であってはならない。
* _トリミングされた_ タグは空白文字を含んではならない。
* _トリミングされた_ タグはISO制御文字を含んではならない。
* _トリミングされた_ タグは次の _予約語_ のいずれも含んではならない。
** `,`：カンマ
** `(`：左カッコ
** `)`：右カッコ
** `&`：アンパサンド
** `|`：縦棒
** `!`：エクスクラメーション

NOTE: 上の文章で、 _トリミングされた_ というのは、
語頭と語尾の空白文字を取り除いたということを意味します。

[source,java]
----
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
----

[[writing-tests-test-instance-lifecycle]]
=== テストインスタンス・ライフサイクル

各テストメソッドの独立した実行と、変化可能なテストインスタンスの状態による
予期せぬ副作用を避けるため、JUnitは各 _テストメソッド_ を実行する前に、
各テストクラスの新しいインスタンスを生成します
（ <<writing-tests-classes-and-methods, テストクラスとメソッド>> をご覧ください）。
この"メソッドごと"のテストインスタンス・ライフサイクルはJUnit Jupiterでは
デフォルトの動作で、以前の全てのバージョンのJUnitと類似したものになっています。


NOTE: `@Disabled` や `@DisabledOnOs` といった <<writing-tests-conditional-execution,条件>> によって
_無効化_ された _テストメソッド_ であっても、テストクラスはインスタンス化されることに注意してください。
これは"メソッドごと"テストインスタンス・ライフサイクルモードが有効である時でも同様です。

JUnit Jupiterに全テストメソッドを同じテストインスタンス上で実行してほしい場合は、
単にテストクラスに `@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与するだけで
実現可能です。このモードを使用する場合、テストクラス毎に新しいテストインスタンスが一度だけ生成されます。
これによって、テストメソッドがインスタンス変数に保存された状態に依存する場合は、
`@BeforeEach` または `@AfterEach` メソッドでその状態をリセットする必要があるかもしれません。

”クラスごと”のモードは、デフォルトの"メソッドごと"モードに比べていくつかの追加的な利点があります。
特に、"クラスごと"モードを使うと、インターフェイスの `default` メソッドと同様に、
`@BeforeAll` と `@AfterAll` メソッドを非静的メソッドとして宣言することが可能になります。
そのため、"クラスごと"モードでは、 `@Nested` テストクラス内で `@BeforeAll` と `@AfterAll` メソッドを使うことができます。

Kotlinプログラミング言語でテストを書いている場合、
”クラスごと”テストインスタンス・ライフサイクルモードに切り替えることで、
`@BeforeAll` と `@AfterAll` メソッドの実装がより容易になるかもしれません。

[[writing-tests-test-instance-lifecycle-changing-default]]
==== デフォルトのテストインスタンス・ライフサイクルの変更

テストクラスまたはテストインターフェイスに `@TestInstance` が付与されていない場合、
JUnit Jupiterは _デフォルト_ のライフサイクルモードを使います。
標準的な _デフォルト_ モードは `PER_METHOD` ですが、
テスト計画全体を実行するための _デフォルト_ を変更することが可能です。
デフォルトのテストインスタンス・ライフサイクルモードを変更するには、
単に `junit.jupiter.testinstance.lifecycle.default` _設定パラメータ_ に
`TestInstance.Lifecycle` に定義されているenum定数名を（大文字・小文字を無視して）設定するだけです。
これは、JVMシステムプロパティとして渡すか、 `Launcher` に渡される `LauncherDiscoveryRequest` 内の
_設定パラメータ_ として渡すか、JUnit Platformの設定ファイル
（詳細については、 <<running-tests-config-params, 設定パラメータ>> をご覧ください。）を通して渡します。

例えば、デフォルトのテストインスタンス・ライフサイクルモードを `LifeCycle.PER_CLASS` に
設定するには、JVMを次のシステムプロパティで起動してください。

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

しかしながら、JUnit Platformの設定ファイルを通してデフォルトの
テストインスタンス・ライフサイクルモードを設定する方が、より堅牢な解決策です。
設定ファイルはプロジェクトのバージョン管理システムに取り込め、
自身のIDEやビルドソフトウェアで利用できます。

JUnit Platformの設定ファイルを通してデフォルトのテストインスタンス・ライフサイクルモードを
設定ためには、次の内容を含んだ `junit-platform.properties` という名前のファイルを
クラスパス（例えば、 `src/test/resources` ）のルートに生成してください。

`junit.jupiter.testinstance.lifecycle.default = per_class`

WARNING: _デフォルト_のテストインスタンス・ライフサイクルモードを変更することは、
一貫性を持って適用しないと、予測不可能な結果と壊れやすいビルドにつながる恐れがあります。
例えば、ビルドではデフォルトとして”クラスごと”のセマンティックを設定していながら、
IDEでのテストでは"メソッドごと"で実行していた場合、ビルドサーバで起きるエラーを
デバッグすることは困難になる恐れがあります。そのため、JVMシステムプロパティの代わりに、
JUnit Platformの設定ファイルを使ってデフォルトを変更することをお薦めします。

[[writing-tests-nested]]
=== ネストされたテスト

ネストされたテストは、テスト開発者が様々なグループのテスト間の関係を表現することを
可能にします。これがその美しい例です。

[source,java]
.スタックをテストするためのネストされたテスト
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.EmptyStackException;
import java.util.Stack;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, () -> stack.pop());
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, () -> stack.peek());
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}
----

NOTE: _非静的なネストされたクラス（つまり、内部クラス）のみ_ が
`@Nested` テストクラスとなります。ネストは任意に深くすることができ、
それら内部クラスは一つの例外を除いて、テストクラスの完全なメンバーとして考えられます。
例外は `@BeforeAll` と `@AfterAll` で、これらは _デフォルト_ では動作しません。
その理由は、Javaが内部クラスに `static` なメンバーを許さないためです。
しかしながら、この制限は `@Nested` テストクラスに `@TestInstance(Lifecycle.PER_CLASS)` を
付与することで回避できます（ <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> をご覧ください）。

[[writing-tests-dependency-injection]]
=== コンストラクタとメソッドへの依存性注入

JUnitの前バージョン全てにおいて、テストコンストラクタまたはメソッドは
（少なくとも標準的な `Runner` 実装を用いる場合は）パラメータを持つことが
許されていませんでした。JUnit Jupiterでの大きな変更の1つとして、
テストコンストラクタとメソッドどちらもパラメータを持てるようになりました。
このことは、大きな柔軟性をもたらし、コンストラクタとメソッドに _依存性の注入_ が
可能になりました。

`{ParameterResolver}` は、実行時に _動的に_ パラメータを解決することを
望むテスト拡張のためのAPIを定義しています。テストコンストラクタまたは `@Test` 、
`@TestFactory` 、 `@BeforeEach` 、 `@AfterEach` 、 `@BeforeAll` 、 `@AfterAll`
メソッドがパラメータを許容する場合は、そのパラメータは登録された `ParameterResolver` に
よって実行時に解決されなければなりません。

現在は、3つの組み込みリゾルバが自動的に登録されます。

* `{TestInfoParameterResolver}` ：メソッドパラメータが `{TestInfo}` 型の場合、
    `TestInfoParameterResolver` はパラメータの値として現在のテストに応じた
    `TestInfo` のインスタンスを供給します。 `TestInfo` は、テストの表示名、テストクラス、
    テストメソッド、関連付けられたタグ名といった現在のテストに関する情報を集めるのに
    使うことができます。表示名は、テストクラスまたはテストメソッドの名前といった技術的な名前か、
    `@DisplayedName` で設定されたカスタム名のどちらかです。

`{TestInfo}` は、JUnit 4の `TestName` 規則の代替として動作します。
次のコードは、テストコンストラクタと `@BeforeEach` メソッド、 `@Test` メソッドに
`TestInfo` を注入させる方法を示しています。

[source,java]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

@DisplayName("TestInfo Demo")
class TestInfoDemo {

    TestInfoDemo(TestInfo testInfo) {
        assertEquals("TestInfo Demo", testInfo.getDisplayName());
    }

    @BeforeEach
    void init(TestInfo testInfo) {
        String displayName = testInfo.getDisplayName();
        assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()"));
    }

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

    @Test
    void test2() {
    }

}
----

* `{RepetitionInfoParameterResolver}`： `@RepeatedTest` または `@BeforeEach` 、
    `@AfterEach` メソッドにおけるメソッドパラメータが `{RepetitionInfo}`型の場合、
    `RepetitionInfoParameterResolver` は `RepetitionInfo` のインスタンスを供給します。
    `RepetitionInfo` は、現在の繰り返しと対応する `@RepeatedTest` の繰り返しの総数に
    関する情報を集めるために利用できます。しかしながら、 `RepetitionInfoParameterResolver` は、
    `@RepeatedTest` の文脈外では登録されていないことに注意してください。
     <<writing-tests-repeated-tests-examples, 繰り返しテストの例>> をご覧ください。
* `{TestReporterParameterResolver}`：メソッドパラメータが `{TestReporter}` 型の場合、
    `TestReporterParameterResolver` は `TestReporter` のインスタンスを供給します。
    `TestReporter` は、現在のテスト実行に関する追加情報を公開するために利用できます。
    そのデータは、 `{TestExecutionListener}.reportingEntryPublished()` を通して消費され、
    IDEに表示またはレポートに含まれます。JUnit Jupiterでは、JUnit 4で `stdout`や
    `stderr` に情報を出力していた箇所に `TestReporter` を使うことができます。
    `@RunWith(JUnitPlatform.class)` を使うと、全てのレポートされたエントリを
    `stdout` に出力します。

[source,java]
----
import java.util.HashMap;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestReporter;

class TestReporterDemo {

    @Test
    void reportSingleValue(TestReporter testReporter) {
        testReporter.publishEntry("a key", "a value");
    }

    @Test
    void reportSeveralValues(TestReporter testReporter) {
        HashMap<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");

        testReporter.publishEntry(values);
    }

}
----

NOTE: 他のパラメータリゾルバは、 `@ExtendWith` を用いた適切な <<extensions,拡張>> を
登録することによって明示的に有効化する必要があります。


カスタム `{ParameterResolver}` の例に関して `{RandomParametersExtension}` を確認しましょう。
リリース可能なものではありませんが、拡張モデルとパラメータ解決プロセス両方の単純さと表現性を
例示しています。 `MyRandomParametersTest` は、 `@Test` メソッドへのランダム値の
挿入方法をを示しています。

[source,java]
----
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

    @Test
    void injectsInteger(@Random int i, @Random int j) {
        assertNotEquals(i, j);
    }

    @Test
    void injectsDouble(@Random double d) {
        assertEquals(0.0, d, 1.0);
    }

}
----

現実的なユースケースとして、 `{MockitoExtension}` と
`{SpringExtension}` のソースコードを確認してください。

[[writing-tests-test-interfaces-and-default-methods]]
=== テストインターフェイスとデフォルトメソッド

JUnit Jupiterは、 `@Test` と `@RepeatedTest` 、 `@ParameterizedTest` 、
`@TestFactory` 、 `@TestTemplate` 、 `@BeforeEach` 、 `@AfterEach` に
インターフェイスの `default` メソッドを宣言できるようにしています。
`@BeforeAll` と `@AfrterAll` はテストインターフェイス内で `static` メソッドを
宣言するか、 _もし_ テストインターフェイスまたはテストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` が付与されている場合は
インターフェイス `default` メソッドを宣言することができます
（ <<writing-tests-test-instance-lifecycle, テストインスタンス・ライフサイクル>> をご覧ください）。
いくつかの例を示します。

[source,java]
----
@TestInstance(Lifecycle.PER_CLASS)
interface TestLifecycleLogger {

    static final Logger LOG = Logger.getLogger(TestLifecycleLogger.class.getName());

    @BeforeAll
    default void beforeAllTests() {
        LOG.info("Before all tests");
    }

    @AfterAll
    default void afterAllTests() {
        LOG.info("After all tests");
    }

    @BeforeEach
    default void beforeEachTest(TestInfo testInfo) {
        LOG.info(() -> String.format("About to execute [%s]",
            testInfo.getDisplayName()));
    }

    @AfterEach
    default void afterEachTest(TestInfo testInfo) {
        LOG.info(() -> String.format("Finished executing [%s]",
            testInfo.getDisplayName()));
    }

}
----

[source,java]
----
interface TestInterfaceDynamicTestsDemo {

    @TestFactory
    default Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test in test interface", () -> assertTrue(true)),
            dynamicTest("2nd dynamic test in test interface", () -> assertEquals(4, 2 * 2))
        );
    }

}
----

`@ExtenWith`と `@Tag` はテストインターフェイスとして宣言することができるため、
インターフェイスを実装したクラスは自動的にタグと拡張を継承します。
<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>> のソースコードを見るには、
<<extensions-lifecycle-callbacks-before-after-execution, BeforeとAfterのテスト実行コールバック>> をご覧ください。

[source,java]
----
@Tag("timed")
@ExtendWith(TimingExtension.class)
interface TimeExecutionLogger {
}
----

テストクラスでは、これらのテストインターフェイスを実装することで適用することができます。

[source,java]
----
class TestInterfaceDemo implements TestLifecycleLogger,
        TimeExecutionLogger, TestInterfaceDynamicTestsDemo {

    @Test
    void isEqualValue() {
        assertEquals(1, 1, "is always equal");
    }

}
----

`TestInterfaceDemo` を実行すると、次と同様の出力が得られます。

[source]
----
:junitPlatformTest
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsFromCollection()]
INFO  example.TimingExtension - Method [dynamicTestsFromCollection] took 13 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsFromCollection()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests

Test run finished after 190 ms
[         3 containers found      ]
[         0 containers skipped    ]
[         3 containers started    ]
[         0 containers aborted    ]
[         3 containers successful ]
[         0 containers failed     ]
[         3 tests found           ]
[         0 tests skipped         ]
[         3 tests started         ]
[         0 tests aborted         ]
[         3 tests successful      ]
[         0 tests failed          ]

BUILD SUCCESSFUL
----

この機能の他のあり得る適用としては、インターフェイス契約のためにテストを書くことです。
例えば、 `Object.equals` または `Comparable.compareTo` の実装が
どう振る舞うべきかのテストを、次のように書くことができます。

[source,java]
----
public interface Testable<T> {

    T createValue();

}
----

[source,java]
----
public interface EqualsContract<T> extends Testable<T> {

    T createNotEqualValue();

    @Test
    default void valueEqualsItself() {
        T value = createValue();
        assertEquals(value, value);
    }

    @Test
    default void valueDoesNotEqualNull() {
        T value = createValue();
        assertFalse(value.equals(null));
    }

    @Test
    default void valueDoesNotEqualDifferentValue() {
        T value = createValue();
        T differentValue = createNotEqualValue();
        assertNotEquals(value, differentValue);
        assertNotEquals(differentValue, value);
    }

}
----

[source,java]
----
public interface ComparableContract<T extends Comparable<T>> extends Testable<T> {

    T createSmallerValue();

    @Test
    default void returnsZeroWhenComparedToItself() {
        T value = createValue();
        assertEquals(0, value.compareTo(value));
    }

    @Test
    default void returnsPositiveNumberComparedToSmallerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(value.compareTo(smallerValue) > 0);
    }

    @Test
    default void returnsNegativeNumberComparedToSmallerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(smallerValue.compareTo(value) < 0);
    }

}
----

テストクラスでは、2つの契約インターフェイスを実装することで、対応するテストを継承します。
もちろん、抽象メソッドを実装する必要があります。

[source,java]
----
class StringTests implements ComparableContract<String>, EqualsContract<String> {

    @Override
    public String createValue() {
        return "foo";
    }

    @Override
    public String createSmallerValue() {
        return "bar"; // 'b' < 'f' in "foo"
    }

    @Override
    public String createNotEqualValue() {
        return "baz";
    }

}
----

NOTE: 上記のテストは、単なる例であって、完全ではありません。

[[writing-tests-repeated-tests]]
=== 繰り返しテスト

JUnit Jupiterは、 `@RepeatedTest` を付与し、繰り返してほしい回数を設定するだけで、
特定回数テストを繰り返す機能を提供しています。
繰り返しテストの各呼び出しは、通常の `@Test` メソッドの実行のように振る舞い、
同じライフサイクル・コールバックと拡張を完全にサポートしています。

次の例は、自動で10回繰り返す `repeatedTest()` という名前のテストの宣言方法を示しています。

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
    // ...
}
----

繰り返し回数の設定に加えて、 `@RepeatedTest` アノテーションの
`name` 属性を用いることでカスタム表示名も設定できます。さらに、表示名は、
静的なテキストと動的なプレースホルダの組み合わせで構成されるパターンにすることもできます。
次のプレースホルダが現在サポートされています。

* `{displayName}`: `@RepeatedTest` メソッドの表示名
* `{currentRepetition}`: 現在の繰り返し回数
* `{totalRepetition}`: 繰り返し回数の合計

ある繰り返し回数時点でのデフォルトの表示名は、次のパターンに基づいて生成されます：
`'repetition {currentRepetition} of {totalRepetitions}'`。
そのため、先ほどの例の各繰り返し回数における表示名は次のようになります：
`repetition 1 of 10` や `repetition 2 of 10` など。
`@RepeatedTest` メソッドの表示名に各繰り返しの名前を含めたい場合は、
独自のカスタムパターンを定義するか、事前定義された `RepeatedTest.LONG_DISPLAY_NAME`
パターンを使うことができます。後者は、 `'{displayName} :: repetition {currentRepetition} of {totalRepetitions}'`
と等しいもので、各繰り返しの表示名は `repeatedTest() :: repetition 1 of 10` や
`repeatedTest() :: repetition 2 of 10` などとなります。

現在の繰り返し回数と繰り返しの合計数の情報をプログラム的に集めるために、
`@RepeatedTest` または `@BeforeEach` 、 `@AfterEach` に
`RepetitionInfo` インスタンスを挿入することができます。

[[writing-tests-repeated-tests-examples]]
==== 繰り返しテストの例

この章の最後にある `RepeatedTestsDemo` クラスは、繰り返しテストの
いくつかの例を示しています。

`repeatedTest()` メソッドは、前章からの例です。
一方、 `repeatedTestWithRepetitionInfo()` は、現在繰り返されているテストの
繰り返し合計数を得るために `RepetitionInfo` インスタンスをテストに注入する方法を
示しています。

その次の2つのメソッドは、 `@RepeatedTest` のカスタム `@DisplayName` を
各繰り返しの表示名内に含ませる方法を示しています。 `customDisplayName()` は
カスタム表示名とカスタムパターンを組み合わせており、 `TestInfo` を使って生成された
表示名のフォーマットを検証しています。 `Repeat!` は `@DisplayName` 宣言から来る
`{displayName}` で、 `1/1` は `{currentRepetition}/{totalRepetitions}` から来ています。
対照的に、 `customDisplayNameWithLongPattern()` は、先ほど説明した事前定義の
`RepeatedTest.LONG_DISPLAY_NAME` パターンを使っています。

`repeatedTestInGerman()` は、繰り返しテストの表示名を他国言語（この場合はドイツ語です）に
翻訳する機能を示しています。その結果、各繰り返しにおける名前は、 `Wiederholung 1 von 5` や
`Wiederholung 2 von 5` などのようになります。

`beforeEach()` メソッドは `@BeforeEach` が付与されているため、
各繰り返しテストの各繰り返し前に実行されます。
`TestInfo` と `RepetitionInfo` をこのメソッドに注入することで、
現在実行されている繰り返しテストに関する情報を得ることができます。
`INFO` ログレベルで `RepeatedTestsDemo` を実行すると出力は次のようになります。

[source]
----
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
----

[source,java]
----
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.logging.Logger;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.TestInfo;

class RepeatedTestsDemo {

    private Logger logger = // ...

    @BeforeEach
    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        String methodName = testInfo.getTestMethod().get().getName();
        logger.info(String.format("About to execute repetition %d of %d for %s", //
            currentRepetition, totalRepetitions, methodName));
    }

    @RepeatedTest(10)
    void repeatedTest() {
        // ...
    }

    @RepeatedTest(5)
    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {
        assertEquals(5, repetitionInfo.getTotalRepetitions());
    }

    @RepeatedTest(value = 1, name = "{displayName} {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeat!")
    void customDisplayName(TestInfo testInfo) {
        assertEquals(testInfo.getDisplayName(), "Repeat! 1/1");
    }

    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)
    @DisplayName("Details...")
    void customDisplayNameWithLongPattern(TestInfo testInfo) {
        assertEquals(testInfo.getDisplayName(), "Details... :: repetition 1 of 1");
    }

    @RepeatedTest(value = 5, name = "Wiederholung {currentRepetition} von {totalRepetitions}")
    void repeatedTestInGerman() {
        // ...
    }

}
----

`ConsoleLauncher` またはunicodeテーマを有効化した `junitPlatformTest` Gradleプラグインを
使うと、 `RepeatedTestsDemo` の実行結果は次のようなコンソール出力を行います。

[source]
----
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
----

[[writing-tests-parameterized-tests]]
=== パラメータ化テスト

パラメータ化テストを使うと、テストを異なる引数で複数回実行できるようになります。
パラメータ化テストは、通常の `@Test` メソッドの代わりに `{ParameterizedTest}`
アノテーションを付与するだけで宣言することができます。
さらに、各呼び出して供給されテストで _消費される_ 引数として、
少なくとも1つの _source_ を宣言する必要があります。

次の例は、パラメータ化テストを示していて、 `@ValueSource` アノテーションを使って
引数のソースとして `String` 配列を指定しています。

[source]
----
@ParameterizedTest
@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })
void palindromes(String candidate) {
    assertTrue(isPalindrome(candidate));
}
----

上記のパラメータ化テストメソッドを実行すると、各呼び出しは別々にレポートされます。
例えば、 `ConsoleLauncher` は次のようなものを出力します。

[source]
----
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
----

WARNING: パラメータ化テストは、現在 _実験的な_ 機能です。
詳細については、 <<api-evolution-experimental-apis, _実験的な_ APIs>> をご覧ください。

[[writing-tests-parameterized-tests-setup]]
==== 必要なセットアップ

パラメータ化テストを使うためには、 `junit-jupiter-params` アーティファクトを
依存関係に加える必要があります。詳細については、 <<dependency-metadata, 依存関係のメタデータ>> をご覧ください。

[[writing-tests-parameterized-tests-consuming-arguments]]
=== 引数の消費

パラメータ化テストメソッドは典型的に、設定されたソース
（  <<writing-tests-parameterized-tests-sources, 引数のソース>> をご覧ください。）
から直接、引数を _消費_ します。引数ソースとメソッドパラメータのインデックスは
1対1の相関関係に従います（ <<writing-tests-parameterized-tests-sources-CsvSource, `@CsvSource`>> の例をご覧ください）。
しかしながら、パラメータ化テストメソッドは、ソースから得た引数をひとつのオブジェクトに
_集約_ して、メソッドに渡すこともできます（ <<writing-tests-parameterized-tests-argument-aggregation, 引数集約>> をご覧ください）。
追加的な引数もまた（例えば、 `TestInfo` や `TestReporter` などのインスタンスを
獲得するために） `ParameterResolver` によって提供されます。
特に、パラメータ化テストメソッドは、次のルールに従って形式的なパラメータを宣言する必要があります。

* まず、0個以上の _インデックスされた引数_ を宣言する。
* 次に、0個以上の _アグリゲータ_ を宣言する。
* 最後に、0個以上の `ParameterResolver` によって供給される引数を宣言する。

この文脈で、 _インデックスされた引数_ とは、 `ArgumentsProvider` によって提供される
`Arguments` 内で与えられたインデックスに対応する引数です。
`ArgumentsProvider` は、パラメータ化メソッドが保持する形式的なパラメータリストにおいて
同じインデックスにあるメソッドに引数として渡されます。 _アグリゲータ_ は、
_ArgumentsAccessor_ 型または _@AggregateWith_ の付与されたパラメータです。

[[writing-tests-parameterized-tests-sources]]
==== 引数のソース

すぐに使えるように、JUnit Jupiterは非常に多くの _ソース_ アノテーションを提供しています。
次の各章はそれぞれ、簡潔な概要とそれぞれの例を提供しています。
さらなる情報に関しては、 `{params-provider-package}` パッケージのJavaDocを参照してください。

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== `@ValueSource`

`@ValueSource` は最も単純なソースの1つです。
リテラル値の配列を1つ設定することができ、パラメータ化テスト呼び出しにつき、
1つのパラメータを提供できます。

次のリテラル値の型が `@ValueSource` にサポートされています。

* `short`
* `byte`
* `int`
* `long`
* `float`
* `double`
* `char`
* `java.lang.String`
* `java.lang.Class`

例えば、次の `@ParameterizedTest` メソッドはそれぞれ `1` 、 `2` 、 `3` の値とともに
3回呼び出されます。

[source,java]
----
@ParameterizedTest
@ValueSource(ints = { 1, 2, 3 })
void testWithValueSource(int argument) {
    assertTrue(argument > 0 && argument < 4);
}
----

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== `@EnumSource`

`@EnumSource` は、 `Enum` 定数に対して便利な機能を提供します。
このアノテーションは、使われる定数を特定するために、オプションで `names` パラメータを
提供します。省略する場合は、次の例のように全ての定数が使われます。

[source,java]
----
@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithEnumSource(TimeUnit timeUnit) {
    assertNotNull(timeUnit);
}
----

[source,java]
----

@ParameterizedTest
@EnumSource(value = TimeUnit.class, names = { "DAYS", "HOURS" })
void testWithEnumSourceInclude(TimeUnit timeUnit) {
    assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
}
----

`@EnumSource` アノテーションはまた、テストメソッドに渡すパラメータを細かく制御するために、
オプションで `mode` パラメータを提供します。例えば、次の例では、enum定数プールから
namesを取り除いたり、正規表現を設定しています。

[source,java]
----
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = EXCLUDE, names = { "DAYS", "HOURS" })
void testWithEnumSourceExclude(TimeUnit timeUnit) {
    assertFalse(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
    assertTrue(timeUnit.name().length() > 5);
}
----

[source,java]
----
@ParameterizedTest
@EnumSource(value = TimeUnit.class, mode = MATCH_ALL, names = "^(M|N).+SECONDS$")
void testWithEnumSourceRegex(TimeUnit timeUnit) {
    String name = timeUnit.name();
    assertTrue(name.startsWith("M") || name.startsWith("N"));
    assertTrue(name.endsWith("SECONDS"));
}
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== `@MethodSource`

`@MethodSource` では、テストクラスまたは外部クラスの _ファクトリー_ メソッドを
1つ以上使うことができます。ファクトリーメソッドは、 `Stream` または `Iterable` 、
`Iterator` 、引数の配列を返す必要があります。さらに、ファクトリーメソッドには
引数を与えられません。テストクラス内のファクトリーメソッドは、テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` が付与されていない限り、
`static` である必要があります。一方、外部クラスのファクトリーメソッドは
常に `static` である必要があります。

パラメータが1つだけ必要な場合は、次の例が示しているように、パラメータの型のインスタンスの`Stream`を返すことができます。

[source,java]
----
@ParameterizedTest
@MethodSource("stringProvider")
void testWithSimpleMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> stringProvider() {
    return Stream.of("foo", "bar");
}
----

`@MethodSource` を通して明示的にファクトリーメソッドの名前を提供しない場合、
JUnit Jupiterは、慣例にならって現在の `@ParameterizedTest` と
同じ名前を持つ _ファクトリー_ メソッドを探します。これを次の例で示します。

[source,java]
----
@ParameterizedTest
@MethodSource
void testWithSimpleMethodSourceHavingNoValue(String argument) {
    assertNotNull(argument);
}

static Stream<String> testWithSimpleMethodSourceHavingNoValue() {
    return Stream.of("foo", "bar");
}
----

`DoubleStream` や `IntStream` 、 `LongStream` といったプリミティブ型の
Streamもまた、次の例のようにサポートされています。

[source,java]
----
@ParameterizedTest
@MethodSource("range")
void testWithRangeMethodSource(int argument) {
    assertNotEquals(9, argument);
}

static IntStream range() {
    return IntStream.range(0, 20).skip(10);
}
----

テストメソッドが複数のパラメータを宣言している場合、
下に示すように `Arguments` インスタンスのコレクションまたはストリームを
返す必要があります。 `Arguments.of(Object...)` は、
`Arguments` インターフェイスで定義されている静的なファクトリーメソッドです。

[source,java]
----
@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(3, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        Arguments.of("foo", 1, Arrays.asList("a", "b")),
        Arguments.of("bar", 2, Arrays.asList("x", "y"))
    );
}
----

外部の `static` _ファクトリー_ メソッドは、
次の例で示すように _完全修飾メソッド名_ によって参照されます。

[source,java]
----
package example;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

class ExternalMethodSourceDemo {

    @ParameterizedTest
    @MethodSource("example.StringsProviders#blankStrings")
    void testWithExternalMethodSource(String blankString) {
        // test with blank string
    }
}

class StringsProviders {

    static Stream<String> blankStrings() {
        return Stream.of("", " ", " \n ");
    }
}
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== `@CsvSource`

`@CsvSource` は、引数リストをコンマ区切りの値（つまり、 `String` リテラル）として
表現できるようにします。

[source,java]
----
@ParameterizedTest
@CsvSource({ "foo, 1", "bar, 2", "'baz, qux', 3" })
void testWithCsvSource(String first, int second) {
    assertNotNull(first);
    assertNotEquals(0, second);
}
----

`@CsvSource` は、シングルクォーテーション `'` を引用文字として使います。
上の例と下の表の `'baz, qux'` の値をご覧ください。
引用された空の値 `''` は、空の `String` となります。
一方、完全に _空_ の値は `null` 参照として解釈されます。
`null` 参照が対象とする型がプリミティブ型の場合、
`ArgumentConversionException` が投げられます。

|===
|入力例 |引数リストの結果

|`@CsvSource({ "foo, bar" })` |`"foo"`, `"bar"`
|`@CsvSource({ "foo, 'baz, qux'" })` |`"foo"` , `"baz, qux"`
|`@CsvSource({ "foo, ''" })` |`"foo"`, `""`
|`@CsvSource({ "foo, " })` |`"foo"`, `null`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== `@CsvFileSource`

`@CsvFileSource` は、CSVファイルをクラスパスから使えるようにします。
パラメータ化テストが1回呼び出される度に、CSVファイルの各行が読み込まれます。

[source,java]
----
@ParameterizedTest
@CsvFileSource(resources = "two-column.csv", numLinesToSkip = 1)
void testWithCsvFileSource(String first, int second) {
    assertNotNull(first);
    assertNotEquals(0, second);
}
----

[source,csv]
.two-column.csv
----
Country, reference
Sweden, 1
Poland, 2
"United States of America", 3
----

NOTE: `@CsvSource` で使われている構文とは対照的に、
`@CsvFileSource` では引用文字としてダブルクォーテーション `"` を使います。
上記の例の `"United States of America"` をご覧ください。
引用された空の値 `””` は、空の `String` となります。
一方、完全に _空_ の値は `null` 参照として解釈されます。
`null` 参照が対象とする型がプリミティブ型の場合、 `ArgumentConversionException` が
投げられます。

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== `@ArgumentSource`

`@ArgumentSource` はカスタムの再利用可能な `ArgumentsProvider` を
特定するために使うことができます。

[source,java]
----
@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}

public class MyArgumentsProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("foo", "bar").map(Arguments::of);
    }
}
----

[[writing-tests-parameterized-tests-argument-conversion]]
==== 引数変換

[[writing-tests-parameterized-tests-argument-conversion-widening]]
===== 拡大的な変換

JUnit Jupiterは `@ParamterizedTest` に供給する引数のために、
https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2[拡大的なプリミティブ変換]を
サポートしています。例えば、 `@ValueSource(ints = { 1, 2, 3 })` が付与された
パラメータ化テストは、 `int` 型のみならず、 `long` や `float` 、 `double` 型の
引数も受けることができます。

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== 暗示的な変換

`@CsvSource` のようなユースケースをサポートするために、
JUnit Jupiterは組み込みの暗示的な型変換をいくつか提供しています。
変換プロセスは、各メソッドパラメータの宣言された型に依存します。

例えば、 `@ParameterizedTest` が `TimeUnit` 型のパラメータを宣言していて、
ソースから供給された実際の型が `String` であった場合、 `String` は
自動的に対応する `TimeUnit` enum定数に変換されます。

[source,java]
----
@ParameterizedTest
@ValueSource(strings = "SECONDS")
void testWithImplicitArgumentConversion(TimeUnit argument) {
    assertNotNull(argument.name());
}
----

`String` インスタンスは現在、次の対象型に暗示的に変換されます。

|===
|対象型 |例

|`boolean`/`Boolean` |`&quot;true&quot;` → `true`
|`byte`/`Byte` |`&quot;1&quot;` → (byte) `1`
|`char`/`Character` |`&quot;o&quot;` → `&#39;o&#39;`
|`short`/`Short` |`&quot;1&quot;` → (short) `1`
|`int`/`Integer` |`&quot;1&quot;` → `1`
|`long`/`Long` |`&quot;1&quot;` → `1L`
|`float`/`Float` |`&quot;1&quot;` → `1.0f`
|`double`/`Double` |`&quot;1&quot;` → `1.0d`
|`Enum`サブクラス |`&quot;SECONDS&quot;` → `TimeUnit.SECONDS`
|`java.io.File` |`&quot;/path/to/file&quot;` → `new File(&quot;path/to/file&quot;)`
|`java.math.BigDecimal` |`&quot;123.456e789&quot;` → `new BigDecimal(&quot;123.456e789&quot;)`
|`java.math.BigInteger` |`&quot;1234567890123456789&quot;` → `new BigInteger(&quot;1234567890123456789&quot;)`
|`java.net.URI` |`&quot;http://junit.org/&quot;` → `URI.create(&quot;http://junit.org/&quot;)`
|`java.net.URL` |`&quot;http://junit.org/&quot;` → `new URL(&quot;http://junit.org/&quot;)`
|`java.nio.file.Path` |`&quot;/path/to/file&quot;` → `Paths.get(&quot;/path/to/file&quot;)`
|`java.time.Instant` |`&quot;1970-01-01T00:00:00Z&quot;` → `Instant.ofEpochMilli(0)`
|`java.time.LocalDateTime` |`&quot;2017-03-14T12:34:56.789&quot;` → `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
|`java.time.LocalDate` |`&quot;2017-03-14&quot;` → `LocalDate.of(2017, 3, 14)`
|`java.time.LocalTime` |`&quot;12:34:56.789&quot;` → `LocalTime.of(12, 34, 56, 789_000_000)`
|`java.time.OffsetDateTime` |`&quot;2017-03-14T12:34:56.789Z&quot;` → `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
|`java.time.OffsetTime` |`&quot;12:34:56.789Z&quot;` → `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
|`java.time.YearMonth` |`&quot;2017-03&quot;` → `YearMonth.of(2017, 3)`
|`java.time.Year` |`&quot;2017&quot;` → `Year.of(2017)`
|`java.time.ZonedDateTime` |`&quot;2017-03-14T12:34:56.789Z&quot;` → `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
|`java.util.Currency` |`&quot;JPY&quot;` → `Currency.getInstance(&quot;JPY&quot;)`
|`java.util.Locale` |`&quot;en&quot;` → `new Locale(&quot;en&quot;)`
|`java.util.UUID` |`&quot;d043e930-7b3b-48e3-bdbe-5a3ccfb833db&quot;` → `UUID.fromString(&quot;d043e930-7b3b-48e3-bdbe-5a3ccfb833db&quot;)`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
===== StringからObjectへの予備的な変換

Stringから上に列挙されている対象型への暗示的な変換に加えて、
JUnit Jupiterでは、対象型が下の定義に合致した _ファクトリーメソッド_ または
_ファクトリーコンストラクタ_ を宣言する場合、 `String`をその対象型へ
自動変換する予備的な機構を提供します。

* _ファクトリーメソッド_ ：対象型で宣言されている非プライベートかつ `static` なメソッドで、
    1つの `String` 引数を取り、対象型のインスタンスを返すもの。
    メソッド名は任意であり、特定の慣習にも従う必要はありません。
* _ファクトリーコンストラクタ_ ：対象型のプライベートでないコンストラクタで、
    1つの `String`引数を取るもの。

NOTE:  複数の _ファクトリーメソッド_ が見つかった場合、それらは無視されます。
_ファクトリーメソッド_ と _ファクトリーコンストラクタ_ が見つかった場合、
ファクトリーメソッドがコンストラクタの代わりに使われます。


例えば、次の `@ParameterizedTest` メソッドの中で、 `Book` 引数は
`Book.fromTitle(String)` ファクトリーメソッドが呼び出されることで生成され、
`"42 Cats"` が本のタイトルとして渡されます。

[source,java]
----
@ParameterizedTest
@ValueSource(strings = "42 Cats")
void testWithImplicitFallbackArgumentConversion(Book book) {
    assertEquals("42 Cats", book.getTitle());
}

public class Book {

    private final String title;

    private Book(String title) {
        this.title = title;
    }

    public static Book fromTitle(String title) {
        return new Book(title);
    }

    public String getTitle() {
        return this.title;
    }
}
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== 明示的な変換

暗黙的な引数変換の代わりに、次の例のように `@ConvertWith` アノテーションを使うことで、
あるパラメータに対して明示的に `ArgumentConverter` を特定することができます。

[source,java]
----
@ParameterizedTest
@EnumSource(TimeUnit.class)
void testWithExplicitArgumentConversion(
        @ConvertWith(ToStringArgumentConverter.class) String argument) {

    assertNotNull(TimeUnit.valueOf(argument));
}

public class ToStringArgumentConverter extends SimpleArgumentConverter {

    @Override
    protected Object convert(Object source, Class<?> targetType) {
        assertEquals(String.class, targetType, "Can only convert to String");
        return String.valueOf(source);
    }
}
----

明示的な引数変換は、テストと拡張の開発者によって実装される必要があります。
そのため、 `junit-jupiter-params` では、参照実装として使える明示的な引数変換器：
`JavaTimeArgumentConverter` を提供しています。
合成アノテーションである `JavaTimeConversionPattern` を通して使うことができます。

[source,java]
----
@ParameterizedTest
@ValueSource(strings = { "01.01.2017", "31.12.2017" })
void testWithExplicitJavaTimeConverter(
        @JavaTimeConversionPattern("dd.MM.yyyy") LocalDate argument) {

    assertEquals(2017, argument.getYear());
}
----

[[writing-tests-parameterized-tests-argument-aggregation]]
==== 引数集約

デフォルトでは、 `@ParameterizedTest` メソッドに渡される各 `引数` は、
1つのメソッドパラメータに対応しています。その結果として、大量の引数を供給することが
期待される引数ソースは、巨大なメソッドシグネチャになる可能性があります。

そのような場合、 `{ArgumentsAccessor}` を複数のパラメータの代わりに使うことができます。
このAPIを使うことで、テストメソッドに渡された1つのパラメータを通して提供された
引数にアクセスすることができます。さらに、 <<writing-tests-parameterized-tests-argument-conversion-implicit, 暗黙的な変換>>
で議論している型変換もサポートしています。

[source,java]
----
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithArgumentsAccessor(ArgumentsAccessor arguments) {
    Person person = new Person(arguments.getString(0),
                               arguments.getString(1),
                               arguments.get(2, Gender.class),
                               arguments.get(3, LocalDate.class));

    if (person.getFirstName().equals("Jane")) {
        assertEquals(Gender.F, person.getGender());
    }
    else {
        assertEquals(Gender.M, person.getGender());
    }
    assertEquals("Doe", person.getLastName());
    assertEquals(1990, person.getDateOfBirth().getYear());
}
----

`ArgumentsAccessor` のインスタンス は、 `ArgumentsAccessor` 型のいかなるパラメータにも自動的に挿入されます。

[[writing-tests-parameterized-tests-argument-aggregation-custom]]
===== カスタムアグリゲータ

`ArgumentsAccessor` を用いた `@ParameterizedTest` メソッドの引数への
直接アクセスとは別に、JUnit Jupiterはカスタムで再利用可能な _アグリゲータ_ の使用も
サポートしています。

カスタムアグリゲータを使うためには、単に `{ArgumentsAggregator}`インターフェイスを実装し、
`@ParameterizedTest` メソッド内で互換可能なパラメータに対して
`@AggregateWith` アノテーションを付与して登録するだけです。
集約の結果は、パラメータ化テストが呼び出された時に、対応するパラメータへの引数として
提供されます。

[source,java]
----
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithArgumentsAggregator(@AggregateWith(PersonAggregator.class) Person person) {
    // perform assertions against person
}

public class PersonAggregator implements ArgumentsAggregator {
    @Override
    public Person aggregateArguments(ArgumentsAccessor arguments, ParameterContext context) {
        return new Person(arguments.getString(0),
                          arguments.getString(1),
                          arguments.get(2, Gender.class),
                          arguments.get(3, LocalDate.class));
    }
}
----

コードベースにまたがって複数のパラメータ化テストに対して繰り返し
`@AggregateWith(MyTypeAggregator.class)` を宣言している場合、
`@AggregateWith(MyTypeAggregator.class)` のメタアノテーションとして
`@CsvToMyType` のようなカスタム _合成アノテーション_ を作成できます。
次の例は、カスタム `@CsvToPerson` アノテーションを用いた動作例を示しています。

[source,java]
----
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithCustomAggregatorAnnotation(@CsvToPerson Person person) {
    // perform assertions against person
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
@AggregateWith(PersonAggregator.class)
public @interface CsvToPerson {
}
----

[[writing-tests-parameterized-tests-display-names]]
==== 表示名のカスタマイズ

デフォルトでは、パラメータ化テスト呼び出しの表示名は、
呼び出しインデックスと特定の呼び出しに対する全ての引数の `String` 表現を含んでいます。
しかしながら、次の例のように `@ParameterizedTest` アノテーションの
`name` 属性によって呼び出し表示名をカスタマイズできます。

[source,java]
----
@DisplayName("Display name of container")
@ParameterizedTest(name = "{index} ==> first=''{0}'', second={1}")
@CsvSource({ "foo, 1", "bar, 2", "'baz, qux', 3" })
void testWithCustomDisplayNames(String first, int second) {
}
----

上記のメソッドを `ConsoleLauncher` を使って実行すると、次のような出力が表示されます。

[source]
----
Display name of container ✔
├─ 1 ==> first='foo', second=1 ✔
├─ 2 ==> first='bar', second=2 ✔
└─ 3 ==> first='baz, qux', second=3 ✔
----

カスタム表示名では、次のプレースホルダがサポートされています。

|===
|プレースホルダ |説明

|{index} |現在の呼び出しインデックス（1始まり）
|{arguments} |完全な引数リスト（CSV形式）
|{0}, {1}, … |各引数
|===

[[writing-tests-parameterized-tests-lifecycle-interop]]
==== ライフサイクルと相互運用性

パラメータ化テストの各呼び出しは、通常の `@Test` メソッドと
同じライフサイクルを持っています。例えば、各呼び出し前には
`@BeforeEach` メソッドが実行されます。
<<writing-tests-dynamic-tests, 動的テスト>> と同じように、
呼び出しはIDEのテストツリーでは一つ一つ表れます。同一のテストクラスに、
自由に `@Test` と `@ParameterizedTest` を混ぜることができます。

`@ParameterizedTest` メソッドと合わせて `ParameterResolver` 拡張を使うことができます。
しかしながら、引数ソースによって解決されたパラメータは、
引数リストの最初に来る必要があります。
テストクラスは様々なパラメータリストを持つパラメータ化テストと同様に
通常のテストを含むこともあるので、引数ソースからの値は `@BeforeEach` といった
ライフサイクルメソッドやテストクラスコンストラクタは解決されません。

[source,java]
----
@BeforeEach
void beforeEach(TestInfo testInfo) {
    // ...
}

@ParameterizedTest
@ValueSource(strings = "foo")
void testWithRegularParameterResolver(String argument, TestReporter testReporter) {
    testReporter.publishEntry("argument", argument);
}

@AfterEach
void afterEach(TestInfo testInfo) {
    // ...
}
----

[[writing-tests-test-templates]]
=== テストテンプレート

`{TestTemplate}` メソッドは、通常のテストケースではなく、
むしろテストケースのためのテンプレートです。
したがって、 `@TestTemplate` は、登録されたプロバイダによって返される
呼び出し文脈の数に応じて複数回呼び出されるものとして設計されています。
そのため、登録された `{TestTemplateInvocationContextProvider}` 拡張と併せて使われる必要があります。
テストテンプレートメソッドの各呼び出しは、通常の `@Test` メソッドの実行と
同じように振る舞い、同じライフサイクルのコールバックと拡張が完全にサポートされています。
用法例については、 <<extensions-test-templates, テストテンプレートに対する呼び出し文脈の提供>> を参照ください。

[[writing-tests-dynamic-tests]]
=== 動的テスト

<<writing-tests-annotations, アノテーション>> で説明したJUnit Jupiterの
標準的な `@Test` アノテーションは、JUnit 4の `@Test` アノテーションに非常に似通っています。
どちらもテストケースを実装したメソッドです。これらのテストケースはコンパイル時に
完全に決定するという意味では静的であり、それらの振る舞いは実行時に変更することはできません。
_アサンプションは、意図的にかなり表現性に制限のあるものですが、動的な振る舞いの基本的な形式を提供します_ 。

これらの標準的なテストに加えて、全く新しい種類のテストプログラミングモデルが
JUnit Jupiterでは導入されました。
この新しいテストとは、 _動的テスト_ です。
動的テストは、 `@TestFactory` が付与されたファクトリーメソッドによって、
実行時に生成されます。

`@Test` メソッドとは対照的に、 `@TestFactory` メソッド自身はテストケースではなく、
むしろテストケースのためのファクトリーです。
そのため、動的テストはファクトリーの産出物となります。
技術的なことを言うと、 `@TestFactory` メソッドは、 `DynamicNode` インスタンスの
`Stream` または `Collection` 、 `Iterable` 、 `Iterator` を返さなければなりません。
`DynamicNode` のインスタンス化可能なサブクラスは `DynamicContainer` と `DynamicTest` です。
`DynamicContainer` インスタンスは、 _表示名_ と動的な子ノードのリストで構成されており、
動的なノードの任意なネスト階層を生成できます。
`DynamicTest` インスタンスは、遅延実行され、テストケースの動的で非決定的な生成が
可能となります。

`@TestFactory` によって返される `Stream` はいずれも、 `stream.close()` を
呼ぶことで適切に閉じられます。これによって、 `Files.lines()` のような資源を
安全に使うことができます。

`@Test` メソッドと同様に、 `@TestFactory` メソッドは `private` または `static` は不可で、
`ParameterResolvers` で解決されるパラメータをオプションで宣言できます。

`DynamicTest` は実行時に生成されるテストケースで、 _表示名_ と `Executable` で
構成されています。 `Executable` は `@FunctionalInterface` で、
このインターフェイスは _ラムダ表現_ または _メソッド参照_ として提供されることができる
動的テストの実装であることを意味します。

.動的テストのライフサイクル
WARNING: 動的テストの実行ライフサイクルは、標準的な `@Test` ケースとは全く異なります。
特に、各動的テストに対してのライフサイクルのコールバックはありません。
このことは、 `@BeforeEach` と `@AfterEach` 、それに対応した拡張コールバックは
`@TestFactory` メソッドに対して実行され、各 _動的テスト_ には実行されないことを意味します。
つまり、動的テストに対してラムダ表現でテストインスタンスからフィールドにアクセスしても、
それらのフィールドは、同じ `@TestFactory` メソッドで生成された
個々の動的テストの実行中は、コールバックメソッドやその拡張によってリセットされません。

JUnit Jupiter {jupiter-version} 時点では、
動的テストは常にファクトリーメソッドによって生成される必要があります。
しかしながら、これは後のリリースにある登録機能によって補完されるかもしれません。

WARNING: 動的テストは現在 _実験的な_ 機能です。
詳細に関しては、 <<api-evolution-experimental-apis, _実験的な_ APIs>> をご覧ください。

[[writing-tests-dynamic-tests-examples]]
==== 動的テストの例

次の `DynamicTestsDemo` クラスは、
テストファクトリーと動的テストのいくつかの例を示しています。

最初のメソッドは不正な型を返しています。
不正な返り値の型はコンパイル時に検出することができないため、
実行時に検出され `JUnitException` が投げられます。

次の5つのメソッドは、 `DynamicTest` インスタンスの `Collection` または `Iterable` 、
`Iterator` 、 `Stream` を生成する非常に単純な例です。
これらの例のほとんどは実際には動的振る舞いを示しておらず、
単に原則的にサポートされている返却型を示しています。
しかしながら、 `dynamicTestsFromStream()` と `dynamicTestsFromIntStream()` は、
`String` のセットや入力値の範囲に対する動的テストの生成がいかに簡単かを示しています。

次のメソッドは、性質上、真に動的なものです。
`generateRandomNumberOfTests()` 、ランダム数を生成する `Iterator` と表示名生成器、
テスト実行器を実装しており、その3つを `DynamicTest.stream()` に提供しています。
`generateRandomNumberOfTests()` の非決定的な振る舞いは、
もちろんテスト反復可能性に抵触しており、注意深く取り扱われるべきではありますが、
動的テストの表現性と能力を示しています。

最後のメソッドは、 `DynamicContainer` を使って動的テストのネスト階層を生成しています。

[source,java]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.junit.jupiter.api.DynamicNode;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.function.ThrowingConsumer;

class DynamicTestsDemo {

    // This will result in a JUnitException!
    @TestFactory
    List<String> dynamicTestsWithInvalidReturnType() {
        return Arrays.asList("Hello");
    }

    @TestFactory
    Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            dynamicTest("1st dynamic test", () -> assertTrue(true)),
            dynamicTest("2nd dynamic test", () -> assertEquals(4, 2 * 2))
        );
    }

    @TestFactory
    Iterable<DynamicTest> dynamicTestsFromIterable() {
        return Arrays.asList(
            dynamicTest("3rd dynamic test", () -> assertTrue(true)),
            dynamicTest("4th dynamic test", () -> assertEquals(4, 2 * 2))
        );
    }

    @TestFactory
    Iterator<DynamicTest> dynamicTestsFromIterator() {
        return Arrays.asList(
            dynamicTest("5th dynamic test", () -> assertTrue(true)),
            dynamicTest("6th dynamic test", () -> assertEquals(4, 2 * 2))
        ).iterator();
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStream() {
        return Stream.of("A", "B", "C")
            .map(str -> dynamicTest("test" + str, () -> { /* ... */ }));
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromIntStream() {
        // Generates tests for the first 10 even integers.
        return IntStream.iterate(0, n -> n + 2).limit(10)
            .mapToObj(n -> dynamicTest("test" + n, () -> assertTrue(n % 2 == 0)));
    }

    @TestFactory
    Stream<DynamicTest> generateRandomNumberOfTests() {

        // Generates random positive integers between 0 and 100 until
        // a number evenly divisible by 7 is encountered.
        Iterator<Integer> inputGenerator = new Iterator<Integer>() {

            Random random = new Random();
            int current;

            @Override
            public boolean hasNext() {
                current = random.nextInt(100);
                return current % 7 != 0;
            }

            @Override
            public Integer next() {
                return current;
            }
        };

        // Generates display names like: input:5, input:37, input:85, etc.
        Function<Integer, String> displayNameGenerator = (input) -> "input:" + input;

        // Executes tests based on the current input value.
        ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);

        // Returns a stream of dynamic tests.
        return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
    }

    @TestFactory
    Stream<DynamicNode> dynamicTestsWithContainers() {
        return Stream.of("A", "B", "C")
            .map(input -> dynamicContainer("Container " + input, Stream.of(
                dynamicTest("not null", () -> assertNotNull(input)),
                dynamicContainer("properties", Stream.of(
                    dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
                    dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
                ))
            )));
    }

}
----